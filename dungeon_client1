#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# pylint: disable=W1203

'''
    ICE Gauntlet LOCAL GAME
'''
import sys
import atexit
import logging
import argparse
import Ice
Ice.loadSlice('IceGauntlet.ice')
import IceGauntlet
import game

import game
import game.common
import game.screens
import game.pyxeltools
import game.orchestration


EXIT_OK = 0
BAD_COMMAND_LINE = 1

DEFAULT_ROOM = 'tutorial.json'
DEFAULT_HERO = game.common.HEROES[0]


@atexit.register
# pylint: disable=W0613
def bye(*args, **kwargs):
    '''Exit callback, use for shoutdown'''
    print('Thanks for playing!')
# pylint: enable=W0613

class RemoteDungeonMap:
    

    def __init__(self,proxy):
        self.dungeon = IceGauntlet.RoomManagerPrx.checkedCast(proxy)
        if not self.dungeon:
            raise RuntimeError('Invalid proxy')

    @property
    def next_room(self):
        return self.dungeon.getRoom()

    @property
    def finished(self):
        return False


def parse_commandline(argv):
    '''Parse and check commandline'''
    argv=argv[1:]
    parser = argparse.ArgumentParser('IceDungeon Local Game')
    parser.add_argument('PROXY', help='Dungeon proxy')
    parser.add_argument(
        '-p', '--player', default=DEFAULT_HERO, choices=game.common.HEROES,
        dest='hero', help='Hero to play with'
    )
    options = parser.parse_args(argv)
    return options    

class Client (Ice.Application):

    def run(self,argv):

        user_options = parse_commandline(argv)
        if not user_options:
            return BAD_COMMAND_LINE

        

        dungeon = RemoteDungeonMap(self.communicator().stringToProxy(user_options.PROXY))
        game.pyxeltools.initialize()
        gauntlet = game.Game(user_options.hero, dungeon)
        gauntlet.add_state(game.screens.TileScreen, game.common.INITIAL_SCREEN)
        gauntlet.add_state(game.screens.StatsScreen, game.common.STATUS_SCREEN)
        gauntlet.add_state(game.screens.GameScreen, game.common.GAME_SCREEN)
        gauntlet.add_state(game.screens.GameOverScreen, game.common.GAME_OVER_SCREEN)
        gauntlet.add_state(game.screens.GoodEndScreen, game.common.GOOD_END_SCREEN)
        gauntlet.start()

        return EXIT_OK


if __name__ == '__main__':
    sys.exit(Client().main(sys.argv))

    
